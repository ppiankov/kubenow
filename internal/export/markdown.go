package export

import (
	"fmt"
	"io"
	"strings"

	"github.com/ppiankov/kubenow/internal/result"
)

// exportMarkdown exports the result as GitHub-flavored Markdown.
func exportMarkdown(resultData interface{}, metadata ExportMetadata, w io.Writer) error {
	var sb strings.Builder

	// Header
	sb.WriteString(fmt.Sprintf("# kubenow Report: %s\n\n", metadata.Mode))
	sb.WriteString(fmt.Sprintf("**Generated:** %s\n", metadata.GeneratedAt.Format("2006-01-02 15:04:05 UTC")))
	if metadata.ClusterName != "" {
		sb.WriteString(fmt.Sprintf("**Cluster:** %s\n", metadata.ClusterName))
	}
	sb.WriteString(fmt.Sprintf("**Mode:** %s\n", metadata.Mode))
	sb.WriteString(fmt.Sprintf("**kubenow Version:** %s\n\n", metadata.KubenowVersion))
	sb.WriteString("---\n\n")

	// Render based on result type
	switch metadata.Mode {
	case "incident":
		if ir, ok := resultData.(*result.IncidentResult); ok {
			renderIncidentMarkdown(&sb, ir)
		}
	case "pod":
		if pr, ok := resultData.(*result.PodResult); ok {
			renderPodMarkdown(&sb, pr)
		}
	case "default":
		if dr, ok := resultData.(*result.DefaultResult); ok {
			renderDefaultMarkdown(&sb, dr)
		}
	case "teamlead":
		if tr, ok := resultData.(*result.TeamleadResult); ok {
			renderTeamleadMarkdown(&sb, tr)
		}
	case "compliance":
		if cr, ok := resultData.(*result.ComplianceResult); ok {
			renderComplianceMarkdown(&sb, cr)
		}
	case "chaos":
		if ch, ok := resultData.(*result.ChaosResult); ok {
			renderChaosMarkdown(&sb, ch)
		}
	default:
		return fmt.Errorf("unsupported mode for markdown export: %s", metadata.Mode)
	}

	// Footer
	sb.WriteString("\n---\n\n")
	sb.WriteString("*Generated by [kubenow](https://github.com/ppiankov/kubenow)*\n")

	_, err := w.Write([]byte(sb.String()))
	return err
}

func renderIncidentMarkdown(sb *strings.Builder, ir *result.IncidentResult) {
	if len(ir.RootCauses) > 0 {
		sb.WriteString("## Root Causes\n\n")
		for _, cause := range ir.RootCauses {
			sb.WriteString(fmt.Sprintf("- %s\n", cause))
		}
		sb.WriteString("\n")
	}

	sb.WriteString("## Top Issues\n\n")
	for i, issue := range ir.TopIssues {
		sb.WriteString(fmt.Sprintf("### %d. %s/%s - %s\n\n", i+1, issue.Namespace, issue.Name, strings.ToUpper(issue.Severity)))
		sb.WriteString(fmt.Sprintf("**Type:** %s\n", issue.IssueType))
		sb.WriteString(fmt.Sprintf("**Summary:** %s\n", issue.Summary))
		if issue.Impact != "" {
			sb.WriteString(fmt.Sprintf("**Impact:** %s\n", issue.Impact))
		}
		sb.WriteString("\n")
	}

	if len(ir.Actions) > 0 {
		sb.WriteString("## Recommended Actions\n\n")
		for _, action := range ir.Actions {
			sb.WriteString(fmt.Sprintf("- %s\n", action))
			// Check for kubectl commands and format them
			if strings.Contains(action, "kubectl") {
				sb.WriteString("```bash\n")
				sb.WriteString(action + "\n")
				sb.WriteString("```\n\n")
			}
		}
		sb.WriteString("\n")
	}

	if len(ir.Notes) > 0 {
		sb.WriteString("## Notes\n\n")
		for _, note := range ir.Notes {
			sb.WriteString(fmt.Sprintf("- %s\n", note))
		}
		sb.WriteString("\n")
	}
}

func renderPodMarkdown(sb *strings.Builder, pr *result.PodResult) {
	sb.WriteString("## Problem Pods\n\n")

	for i, pod := range pr.Pods {
		sb.WriteString(fmt.Sprintf("### %d. %s/%s - %s\n\n", i+1, pod.Namespace, pod.Name, strings.ToUpper(pod.Severity)))
		sb.WriteString(fmt.Sprintf("**Type:** %s\n", pod.IssueType))
		if pod.FailingContainer != "" {
			sb.WriteString(fmt.Sprintf("**Failing Container:** %s\n", pod.FailingContainer))
		}
		sb.WriteString(fmt.Sprintf("**Summary:** %s\n", pod.Summary))
		if pod.RootCause != "" {
			sb.WriteString(fmt.Sprintf("**Root Cause:** %s\n", pod.RootCause))
		}
		sb.WriteString("\n")

		if len(pod.FixCommands) > 0 {
			sb.WriteString("**Fix Commands:**\n```bash\n")
			for _, cmd := range pod.FixCommands {
				sb.WriteString(cmd + "\n")
			}
			sb.WriteString("```\n\n")
		}

		if pod.Notes != "" {
			sb.WriteString(fmt.Sprintf("**Notes:** %s\n\n", pod.Notes))
		}
	}
}

func renderDefaultMarkdown(sb *strings.Builder, dr *result.DefaultResult) {
	sb.WriteString("## Cluster Summary\n\n")
	sb.WriteString(fmt.Sprintf("- **Problem Pods:** %d\n", dr.Summary.ProblemPodCount))
	sb.WriteString(fmt.Sprintf("- **Node Readiness:** %s\n", dr.Summary.NodeReadiness))
	sb.WriteString(fmt.Sprintf("- **Resource Pressure:** %s\n", dr.Summary.ResourcePressure))

	if len(dr.Summary.NamespacesWithIssues) > 0 {
		sb.WriteString(fmt.Sprintf("- **Namespaces with Issues:** %s\n", strings.Join(dr.Summary.NamespacesWithIssues, ", ")))
	}
	sb.WriteString("\n")

	if len(dr.Issues) > 0 {
		sb.WriteString("### Issues Detected\n\n")
		for i, issue := range dr.Issues {
			sb.WriteString(fmt.Sprintf("%d. **%s/%s** (%s) - %s: %s\n", i+1, issue.Namespace, issue.Name, issue.Severity, issue.IssueType, issue.ShortSummary))
		}
		sb.WriteString("\n")
	}

	if len(dr.Recommendations) > 0 {
		sb.WriteString("### Recommendations\n\n")
		for _, rec := range dr.Recommendations {
			sb.WriteString(fmt.Sprintf("- %s\n", rec))
		}
		sb.WriteString("\n")
	}
}

func renderTeamleadMarkdown(sb *strings.Builder, tr *result.TeamleadResult) {
	if len(tr.BusinessRisk) > 0 {
		sb.WriteString("## Business Risk\n\n")
		for _, risk := range tr.BusinessRisk {
			sb.WriteString(fmt.Sprintf("- %s\n", risk))
		}
		sb.WriteString("\n")
	}

	if len(tr.OwnershipHints) > 0 {
		sb.WriteString("### Ownership Hints\n\n")
		for _, hint := range tr.OwnershipHints {
			sb.WriteString(fmt.Sprintf("- %s\n", hint))
		}
		sb.WriteString("\n")
	}

	if len(tr.TopActions) > 0 {
		sb.WriteString("### Top Actions\n\n")
		for i, action := range tr.TopActions {
			sb.WriteString(fmt.Sprintf("%d. %s\n", i+1, action))
		}
		sb.WriteString("\n")
	}

	if len(tr.Escalation) > 0 {
		sb.WriteString("### Escalation Path\n\n")
		for _, esc := range tr.Escalation {
			sb.WriteString(fmt.Sprintf("- %s\n", esc))
		}
		sb.WriteString("\n")
	}
}

func renderComplianceMarkdown(sb *strings.Builder, cr *result.ComplianceResult) {
	sb.WriteString("## Compliance Issues\n\n")

	if len(cr.Issues) == 0 {
		sb.WriteString("*No compliance issues detected.*\n\n")
		return
	}

	for i, issue := range cr.Issues {
		sb.WriteString(fmt.Sprintf("### %d. %s/%s - %s\n\n", i+1, issue.Namespace, issue.Name, strings.ToUpper(issue.Severity)))
		sb.WriteString(fmt.Sprintf("**Type:** %s\n", issue.Type))
		sb.WriteString(fmt.Sprintf("**Description:** %s\n", issue.Description))
		if issue.Recommendation != "" {
			sb.WriteString(fmt.Sprintf("**Recommendation:** %s\n", issue.Recommendation))
		}
		sb.WriteString("\n")
	}
}

func renderChaosMarkdown(sb *strings.Builder, ch *result.ChaosResult) {
	if len(ch.Vulnerabilities) > 0 {
		sb.WriteString("## Identified Vulnerabilities\n\n")
		for _, vuln := range ch.Vulnerabilities {
			sb.WriteString(fmt.Sprintf("- %s\n", vuln))
		}
		sb.WriteString("\n")
	}

	if len(ch.Experiments) > 0 {
		sb.WriteString("## Recommended Chaos Experiments\n\n")
		for i, exp := range ch.Experiments {
			sb.WriteString(fmt.Sprintf("### Experiment %d: %s\n\n", i+1, exp.Name))
			sb.WriteString(fmt.Sprintf("**Reason:** %s\n\n", exp.Reason))
			sb.WriteString(fmt.Sprintf("**Description:**\n%s\n\n", exp.Description))
		}
	}

	if len(ch.ImpactNotes) > 0 {
		sb.WriteString("### Impact Notes\n\n")
		for _, note := range ch.ImpactNotes {
			sb.WriteString(fmt.Sprintf("- %s\n", note))
		}
		sb.WriteString("\n")
	}
}
